using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;

using GameSparks.Api.Requests;
using GameSparks.Api.Responses;
using GameSparks.Core;

public class Backend : MonoBehaviour {

	// keys used to access values on the backend data platform
	const string saveEventKey = "SAVED_PLAYER_DATA";
	const string loadEventKey = "LOAD_PLAYER_DATA";
	const string leaderboardEventKey = "SUBMIT_SCORE";
	const string leaderboardShortcode = "highScores";

	// cached int from cloud which stores last loaded level
	public int lastLevelPlayed { get; set; }

	public static Backend manager; // singleton

	// cached string from cloud which stores player registered display name
	public string displayName { get; set; }

	// singleton initialization
	void Awake() {
		if( Backend.manager ) {
			DestroyImmediate( gameObject );
			return;
		}
		else {
			manager = this;
			DontDestroyOnLoad( gameObject );
		}
	}

	// generic method for reporting an analytic to the backend that ties a key to a json string
	// the callback delegate is what will get called with a response from the backend server
	public void ReportAnalytic( string key, string json = "", Action<AnalyticsResponse> callback = null ) {
		if( callback == null ) callback = EmptyAnalyticsCallback; // the callback is optional, so if it's not supplied, use a default option

		// the request handles data transfer to GameSparks
		AnalyticsRequest request = new AnalyticsRequest()
			.SetKey( key );

		if( json != "" ) {
			request.SetData( new GSRequestData( json ) ); // GameSparks has its own structure for data, but it takes a json payload
		}

		// initiate the web request
		request.Send( EmptyAnalyticsCallback );
	}

	// set a set of integer values based on a set of string keys in the cloud, using a master key for all player save data ("saveEventKey")
	// setting a group of values at once is more efficient than multiple requests
	public void SetCloudData( params IntAttribute[] values ) {
		LogEventRequest request = new LogEventRequest().SetEventKey( saveEventKey );

		foreach( IntAttribute attribute in values ) {
			request.SetEventAttribute( attribute.key, attribute.val ); // more custom GameSparks structures
		}

		request.Send( EmptyEventCallback );
	}

	// the opposite of SetCloudData, this method gets an array of ints back from string keys via a callback that is called on server response
	public void GetCloudInts( string[] keys, Action<int[]> callback ) {
		int[] values = new int[keys.Length]; // by default, the int array is empty, so you get something back even if the response fails

		// here we supply an anonymous method to the callback so we can pack the response logic together with the request logic
		new LogEventRequest().SetEventKey( loadEventKey ).Send( response => {
			if( !response.HasErrors ) {
				GSData data = response.ScriptData.GetGSData("playerData"); // this "ScriptData" is generated by cloud code on the GameSparks backend

				for( int index = 0; index < keys.Length; index++ ) {
					values[index] = (int)data.GetInt( keys[index] ); // extract the int keys from the GameSparks data structure
				}

				callback( values ); // tell the original caller of this method that we've got the data it wants, and supply it
			}
			else {
				// when there's an error with a backend network request, make sure it's reported in red
				Debug.LogError( "Error from event backend: " + response.Errors.JSON.ToString() );

				callback( null );
			}
		} );
	}

	// send data to the backend leaderboard data store
	public void UpdateLeaderboard( int[] intTimes ) {

		// serialize some json that represents the times this player has recorded for each level
		TimesPerLevel times = new TimesPerLevel { times = intTimes };
		string json = JsonUtility.ToJson( times );

		LogEventRequest request = new LogEventRequest().SetEventKey( leaderboardEventKey );

		// this event is set up in GameSparks and used by the leaderboard for ranking
		request.SetEventAttribute( "averageTime", intTimes.Average().ToString() );

		// this json hitches along for the ride as a payload that we'll use when unpacking the data on other clients
		// we want this because our leaderboards aren't a simple numerical score, but scores per level
		request.SetEventAttribute( "times", json );

		request.Send( EmptyEventCallback );
	}

	// return data from the backend leaderboard store
	public void GetLeaderboardTimes( Action<List<LeaderboardInfo>> callback ) {

		List<LeaderboardInfo> leaderboardInfos = new List<LeaderboardInfo>();

		// more GameSparks structures.  This one can have a maximum entry count supplied
		new LeaderboardDataRequest().SetLeaderboardShortCode( leaderboardShortcode ).SetEntryCount( 10 ).Send( response => {

			if( !response.HasErrors ) {
				// found leaderboard data

				// some obscurely named GameSparks structures
				foreach( LeaderboardDataResponse._LeaderboardData entry in response.Data ) {

					string timesJson = entry.JSONData["times"].ToString(); // pull the json payload out of the response
					int[] times = JsonUtility.FromJson<TimesPerLevel>( timesJson ).times; // reconstruct the int list from json
					int playerRank = (int) entry.Rank; // we could rank the players, visually, with this
					string playerName = entry.UserName;

					// pack this info into a convenience class and stick it in a list for eventual delivery back to the requesting method
					LeaderboardInfo leaderboardInfo = new LeaderboardInfo {
						timesByLevel = times,
						rank = playerRank,
						name = playerName
					};

					leaderboardInfos.Add( leaderboardInfo );
				}

				// tell the original caller of this method that we've fetched the data they've asked for
				callback( leaderboardInfos );
			}
			else {
				Debug.Log( "Error Retrieving Leaderboard Data... " + response.Errors.JSON.ToString());
			}
		});
	}

	void EmptyAnalyticsCallback( AnalyticsResponse response ) {
		if( response.HasErrors ) {
			Debug.LogError( "Error from analytics: " + response.Errors.JSON.ToString() );
		}
	}

	void EmptyEventCallback( LogEventResponse response ) {
		if( response.HasErrors ) {
			Debug.LogError( "Error from event backend: " + response.Errors.JSON.ToString() );
		}
		else {
			Debug.Log( "Successfully saved event to backend" );
		}
	}

	// wrapper class only used by this class for converting to json
	class TimesPerLevel {
		public int[] times;
	}
}